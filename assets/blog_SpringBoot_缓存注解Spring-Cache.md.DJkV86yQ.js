import{_ as i,o as a,c as t,a6 as n}from"./chunks/framework.BkI9ovSD.js";const h="/assets/587.CBez-u22.png",e="/assets/588.cu3_KsZ5.png",p="/assets/589.DOa4jnSc.png",l="/assets/590.BSjPgb82.png",k="/assets/591.DWJGW5Co.png",C=JSON.parse('{"title":"缓存注解Spring-Cache","description":"","frontmatter":{"date":"2023-05-16T00:00:00.000Z","tags":["Redis","Middleware","Cache","Spring Cache"],"categories":["SpringBoot"]},"headers":[],"relativePath":"blog/SpringBoot/缓存注解Spring-Cache.md","filePath":"blog/SpringBoot/缓存注解Spring-Cache.md","lastUpdated":1740470114000}'),d={name:"blog/SpringBoot/缓存注解Spring-Cache.md"};function r(E,s,g,o,c,y){return a(),t("div",{"data-pagefind-body":!0},s[0]||(s[0]=[n(`<h1 id="缓存注解spring-cache" tabindex="-1">缓存注解Spring-Cache <a class="header-anchor" href="#缓存注解spring-cache" aria-label="Permalink to &quot;缓存注解Spring-Cache&quot;">​</a></h1><p>本文会介绍一种兼容所有缓存中间件的方案： <code>Spring Cache</code>，不论我们是使用 Redis 还是 Ehcache，都不需要关心如何操作 Redis 或者 Ehcache，这套方案会统统帮你搞定。</p><h2 id="揭开-spring-cache-的面纱" tabindex="-1">揭开 Spring Cache 的面纱 <a class="header-anchor" href="#揭开-spring-cache-的面纱" aria-label="Permalink to &quot;揭开 Spring Cache 的面纱&quot;">​</a></h2><h3 id="现有缓存方案的痛点" tabindex="-1">现有缓存方案的痛点 <a class="header-anchor" href="#现有缓存方案的痛点" aria-label="Permalink to &quot;现有缓存方案的痛点&quot;">​</a></h3><p><strong>试想一种场景</strong>：</p><ol><li><p>用户 A 打开 APP，进入到了秒杀商品的详情页，那这个商品数据我们会先去数据库查询，然后返回给客户端。</p></li><li><p>因为有大量用户短时间内进入到了详情页，所以可以把活动列表缓存起来，直接读缓存就可以了。</p></li><li><p>那下次再查询商品时，直接去缓存查询就可以了。如果秒杀商品下架了，缓存的数据不会用到了，就把缓存删掉就可以了。</p></li><li><p>上面几步看起来也没啥问题，但是 <strong>放缓存，删除缓存这两步是需要我们去手动写代码实现的</strong>。有没有一种方式 <strong>不用写操作缓存的代码</strong>？</p></li><li><p>假如现在用的缓存中间件是 Redis，领导说要换成 Ehcache，那 <strong>原本操作缓存的代码是不是又得重新写一遍</strong>？</p></li></ol><p><strong>总结下上面场景的痛点：</strong></p><ul><li>需要手写操作缓存代码，如添加缓存、更新缓存、删除缓存。</li><li>切换缓存组件并不容易，或者说没有对缓存层进行抽象封装，依赖具体的缓存中间件。</li></ul><p>哪有没有一种方案可以帮助解决上面的两个痛点呢？</p><p>这就是今天要介绍的 <code>Spring Cache</code>。</p><h3 id="spring-cache-介绍" tabindex="-1">Spring Cache 介绍 <a class="header-anchor" href="#spring-cache-介绍" aria-label="Permalink to &quot;Spring Cache 介绍&quot;">​</a></h3><p>Spring Cache 是 Spring 提供的一整套的缓存解决方案。虽然它本身并没有提供缓存的实现，但是它提供了一整套的接口和代码规范、配置、注解等，这样它就可以整合各种缓存方案了，比如 Redis、Ehcache，我们也就不用关心操作缓存的细节。</p><p>Spring 3.1 开始定义了 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口来统一不同的缓存技术，并支持使用注解来简化我们开发。</p><p><code>Cache</code> 接口它包含了缓存的各种操作方式，同时还提供了各种 <code>xxxCache</code> 缓存的实现，比如 RedisCache 针对Redis，EhCacheCache 针对 EhCache，ConcurrentMapCache 针对 ConCurrentMap，具体有哪几种，后面实战中会介绍。</p><h3 id="spring-cache-的功能和效果" tabindex="-1">Spring Cache 的功能和效果 <a class="header-anchor" href="#spring-cache-的功能和效果" aria-label="Permalink to &quot;Spring Cache 的功能和效果&quot;">​</a></h3><p>每次调用某方法，而此方法又是带有缓存功能时，Spring 框架就会检查 <code>指定参数</code> 的那个方法是否已经被调用过，如果之前调用过，就从缓存中取之前调用的结果；如果没有调用过，则再调用一次这个方法，并缓存结果，然后再返回结果，那下次调用这个方法时，就可以直接从缓存中获取结果了。</p><h3 id="spring-cache-的原理" tabindex="-1">Spring Cache 的原理 <a class="header-anchor" href="#spring-cache-的原理" aria-label="Permalink to &quot;Spring Cache 的原理&quot;">​</a></h3><p>Spring Cache 主要是作用在类上或者方法上，对类中的方法的返回结果进行缓存。那么如何对方法进行增强，来实现缓存的功能呢？</p><p><strong>学过 Spring 的同学，肯定能一下子就反应过来，就是用 <code>AOP</code>（面向切面编程）。</strong></p><p>面向切面编程可以简单地理解为在类上或者方法前加一些说明，就是我们常说的注解。</p><p>Spring Cache 的注解会帮忙在方法上创建一个切面（aspect），并触发缓存注解的切点（poinitcut），听起来太绕了，简单点说就是：Spring Cache 的注解会帮忙在调用方法之后，去缓存 <strong>方法调用的最终结果</strong>，或者在方法调用之前拿缓存中的结果，或者删除缓存中的结果，这些读、写、删缓存的 <strong>脏活</strong> 都交给 Spring Cache 来做了，是不是很爽，再也不用自己去写缓存操作的逻辑了。</p><h2 id="缓存注解" tabindex="-1">缓存注解 <a class="header-anchor" href="#缓存注解" aria-label="Permalink to &quot;缓存注解&quot;">​</a></h2><p>Spring 提供了四个注解来声明缓存规则：</p><table tabindex="0"><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Cacheable</td><td>在调用方法前，首先去缓存中找方法的返回值，如果能找到，则返回缓存的值；<br>否则就执行这个方法，并将返回值放到缓存中</td></tr><tr><td>@CachePut</td><td>在方法调用前不会去缓存中找，而是直接执行此方法，执行后将缓存放入缓存中</td></tr><tr><td>@CacheEvict</td><td>清理缓存中的一条或多条记录</td></tr><tr><td>@Caching</td><td>能够同时应用多个缓存注解</td></tr><tr><td>@CacheConfig</td><td>在类级别共享相同的缓存的配置</td></tr></tbody></table><p>大家先有个概念，后面我们再来看怎么使用这些缓存注解。</p><h2 id="使用缓存" tabindex="-1">使用缓存 <a class="header-anchor" href="#使用缓存" aria-label="Permalink to &quot;使用缓存&quot;">​</a></h2><h3 id="引入-spring-cache-依赖" tabindex="-1">引入 Spring Cache 依赖 <a class="header-anchor" href="#引入-spring-cache-依赖" aria-label="Permalink to &quot;引入 Spring Cache 依赖&quot;">​</a></h3><p>在 pom 文件中引入 spring cache 依赖，如下所示：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;spring-boot-starter-cache&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="配置使用哪种缓存" tabindex="-1">配置使用哪种缓存 <a class="header-anchor" href="#配置使用哪种缓存" aria-label="Permalink to &quot;配置使用哪种缓存&quot;">​</a></h3><p>Spring Cache 支持很多 <strong>缓存中间件</strong> 作为框架中的缓存，总共有 9 种选择：</p><ul><li>caffeine：一种高性能的缓存库，基于 Google Guava</li><li>couchbase：一款非关系型 JSON 文档数据库。</li><li>generic：由泛型机制和 static 组合实现的泛型缓存机制</li><li>hazelcast：一个高度可扩展的数据分发和集群平台，可用于实现分布式数据存储、数据缓存。</li><li>infinispan：分布式的集群缓存系统。</li><li>jcache：它是 JSR107 规范中提到的缓存规范</li><li>none：没有缓存</li><li>redis：用 Redis 作为缓存</li><li>simple：用内存作为缓存</li></ul><p>我们还是用最熟悉的 Redis 作为缓存吧。配置 Redis 作为缓存也很简单，在配置文件 <code>application.yml</code> 中设置缓存的类型为 Redis 就可以了，配置项为 <code>spring.cache.type</code> ：</p><p><img src="`+h+`" alt="图片"></p><p>当然，别忘了还要在 pom 文件中 引入 Redis 的依赖，不然用不了 Redis：</p><div class="language-XML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">XML</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;org.springframework.boot&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;spring-boot-starter-data-redis&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>同时在 yml 里配置好 Redis：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    redis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # Redis服务器地址</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      host</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">127.0.0.1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # Redis服务器连接端口</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      port</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6379</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # Redis服务器连接密码（默认为空）</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      password</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      database</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #Redis数据库索引（默认为0号数据库）</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      lettuce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        pool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          max-active</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 连接池最大连接数（使用负值表示没有限制）</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          max-wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">-1ms</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          max-idle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 连接池中的最大空闲连接</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          min-idle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 连接池中的最小空闲连接</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      connect-timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">PT10S</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 连接超时时间（秒）</span></span></code></pre></div><p>那基础的配置已经做好了，现在就是看怎么使用 Spring Cache 了。</p><h3 id="启动类上添加-enablecaching-注解-开启缓存支持" tabindex="-1">启动类上添加 <code>@EnableCaching</code> 注解，开启缓存支持 <a class="header-anchor" href="#启动类上添加-enablecaching-注解-开启缓存支持" aria-label="Permalink to &quot;启动类上添加 \`@EnableCaching\` 注解，开启缓存支持&quot;">​</a></h3><p><img src="`+e+`" alt="图片"></p><h3 id="指定某方法开启缓存功能-在方法上添加-cacheable-缓存注解" tabindex="-1">指定某方法开启缓存功能，在方法上添加 <code>@Cacheable</code> 缓存注解 <a class="header-anchor" href="#指定某方法开启缓存功能-在方法上添加-cacheable-缓存注解" aria-label="Permalink to &quot;指定某方法开启缓存功能，在方法上添加 \`@Cacheable\` 缓存注解&quot;">​</a></h3><p><code>@Cacheable</code> 注解中，可以添加四种参数：</p><ul><li><p><strong>value</strong>：用于指定缓存的名称或缓存的分组。该参数是一个字符串数组类型，可以指定多个缓存名称或分组，用逗号分隔。这些缓存名称和分组在配置中被定义，并且每个缓存名称对应一个具体的缓存实现。</p></li><li><p><strong>key</strong>：用于指定缓存的键。缓存的键是根据 key 参数的表达式计算得出的，可以使用 SpEL（Spring Expression Language）表达式或者简单的字符串指定。在缓存中，键的唯一性决定了数据的唯一性，不同的键对应着不同的缓存值。</p><ul><li>当省略 key 参数时，默认使用方法的所有参数作为键，要求方法的参数对象必须实现 hashCode 方法。</li><li>当指定 key 参数时，可以根据方法的参数、返回值、类名等来构建唯一的缓存键。</li></ul></li><li><p><strong>condition</strong>：触发条件。这个参数是规定这个缓存触发的条件拼接，例如 <code>condition=&quot;#area.id != 1&quot;</code>，就是在 id 不为1的时候触发缓存。</p></li><li><p><strong>unless</strong>：排除条件。这个参数是规定这个缓存在何时不触发，例如 <code>unless=&quot;#result == null&quot;</code>，不对查询结果为 NULL 的结果进行缓存。</p></li></ul><p>首先我们来看下 value 参数。</p><p>下面的代码出于演示作用，用了最简单的逻辑，test 方法直接返回一个数字，连数据库查询都没有做。不过没关系，我们主要验证 Spring Cache 是否对方法的结果进行了缓存。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Cacheable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 222</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>大家注意，<code>@Cacheable</code> 注解中小括号里面还含有大括号，大括号里面还有 “hot” 字符串，这个 hot 字符串你可以把它当作一个缓存的名字，然后将 test 方法返回的结果存到 hot 缓存中。我们也可以用 value=&quot;hot&quot; 的方式。</p><p><code>@Cacheable</code> 调用的是 Redis 的 set 函数，生成的 Key 为 value 和 key 两个字符串通过 <code>::</code> 进行拼接的。</p><p>第一次调用 test 方法前，既没有 hot 缓存，更没有 test 的结果缓存。</p><p>调用 test 方法后，Redis 中就创建出了 hot 缓存了，然后缓存了一个 Key，如下图所示：</p><p><img src="`+p+`" alt="图片"></p><p>第二次调用 test 方法时，就从缓存 hot 中将 test 方法缓存的结果 222 取出来了，为了验证没有执行 test 中的方法，大家可以在 test 方法中打下 log 或者断点。最后的验证结果肯定是没有走 test 方法的，而是直接从缓存中获取的。</p><p>那我们再来测试一个方法，方法名改为 test2，且请求路径也改为 test2 了。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/test2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Cacheable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 456</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>大家觉得这两个方法的结果都会缓存吗？还是只会缓存第一个被调用的方法？</strong></p><p>经过测试，执行第一个 test 方法后，再执行 test2 方法，缓存结果一直是 222 不会变。因为他们的 key 都是 默认的 <code>hot::SimpleKey[]</code>，所以两个方法对应的缓存的 key 都叫这个，所以得到的缓存值是一样的。</p><h3 id="加上数据库查询的测试" tabindex="-1">加上数据库查询的测试 <a class="header-anchor" href="#加上数据库查询的测试" aria-label="Permalink to &quot;加上数据库查询的测试&quot;">​</a></h3><p>有的同学可能觉得上面的测试太简单了，test 方法里面啥都没做，还缓存啥呢，完全没必要啊。没关系，大家的顾虑是对的，我们来加上数据库查询。</p><p>先说下场景：前端需要查询某个题目的详情，正常逻辑是查询数据库后返回结果。假定这个查询操作非常频繁，我们需要将题目详情进行缓存。我们先看看常规的 Redis 缓存方案：</p><p>先从 Redis 缓存中查看缓存中是否有该题目，如果缓存中有，则返回缓存中的题目；如果没有，就从数据库中查。查询出题目后，就用 Redis 存起来，然后返回。这里就要写操作 Redis 的代码了：查询 Redis 缓存、更新 Redis 缓存。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查询缓存，假定该题目详情缓存的 key=question1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;question1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新缓存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;question1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, questionEntity);</span></span></code></pre></div><p>那如果用 Spring Cache 注解的话，上面两行代码可以直接干掉了。如下所示，加一个 <code>@Cacheable</code> 注解搞定。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Cacheable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;question&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QuestionEntity </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Long id) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查询数据库操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其中 question 和 hot 是缓存的名字，我们可以将结果放到不同的缓存中。</p><p>结论：</p><ul><li>如果方法没有传入参数并且没有注解 <code>@Cacheable</code> 没有注明 key，则缓存生成的 key，是默认自动生成的，叫做 <code>SimpleKey[]</code>。</li><li>如果方法有传入参数但注解 <code>@Cacheable</code> 没有注明 key，则缓存的 key 就是请求参数，比如上面 info 方法，key 等于我传入的 id = 1。</li><li>缓存中 key 对应的 value <strong>默认使用 JDK 序列化后的数据</strong>。</li><li>value 的过期时间为 -1，表示永不过期。</li></ul><h3 id="自定义配置类" tabindex="-1">自定义配置类 <a class="header-anchor" href="#自定义配置类" aria-label="Permalink to &quot;自定义配置类&quot;">​</a></h3><p>上面保存的缓存数据都是默认设置，我们也可以自己定义配置，如下所示，在配置文件 application.properties 添加如下配置：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用 Redis 作为缓存组件</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">redis</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    redis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # 缓存过期时间为 3600s</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      time-to-live</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3600000</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # 缓存的键的名字前缀</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      key-prefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">passjava_</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # 是否使用缓存前缀</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      use-key-prefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # 是否缓存控制，防止缓存穿透</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      cache-null-values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p>然后需要加一个配置类：MyCacheConfig。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">EnableConfigurationProperties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CacheProperties.class)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">EnableCaching</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyCacheConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    CacheProperties cacheProperties;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Bean</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RedisCacheConfiguration </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redisCacheConfiguration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CacheProperties </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cacheProperties</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        RedisCacheConfiguration config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedisCacheConfiguration.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defaultCacheConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">serializeKeysWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RedisSerializationContext.SerializationPair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromSerializer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringRedisSerializer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">serializeValuesWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RedisSerializationContext.SerializationPair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromSerializer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenericJackson2JsonRedisSerializer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        CacheProperties.Redis redisProperties </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cacheProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRedis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (redisProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTimeToLive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">entryTtl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redisProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTimeToLive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (redisProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getKeyPrefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prefixKeysWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redisProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getKeyPrefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isCacheNullValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disableCachingNullValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redisProperties.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isUseKeyPrefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disableKeyPrefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="自定义-key" tabindex="-1">自定义 key <a class="header-anchor" href="#自定义-key" aria-label="Permalink to &quot;自定义 key&quot;">​</a></h3><p>然后我们可以指定 key 的值，可以在 <code>@Cacheable</code> 注解里面加上 key 的值 <code>#root.method.name</code>。</p><p>这是一种特有的表达式，称作 <strong>SpEL 表达式</strong>，这里代表用方法名作为缓存 key 的名字：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Cacheable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;#root.method.name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>接下来就是见证奇迹的时刻，调用 test 方法和 test2 方法，发现有两个不同的 key，一个是 <code>passjava_test1</code>，另外一个 <code>passjava_test2</code>，它们的 key 就是 <code>缓存的键的名字前缀 + 方法名</code> 组成。</p><p><img src="`+l+`" alt="图片"></p><p>SpEL 表达式还有很多其它规则，如下所示：</p><table tabindex="0"><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>#root.args</td><td>传递给缓存方法的参数，形式为数组</td></tr><tr><td>#root.caches</td><td>该方法执行时所对应的缓存，形式为数组</td></tr><tr><td>#root.target</td><td>目标对象</td></tr><tr><td>#root.targetClass</td><td>目标对象的类</td></tr><tr><td>#root.method</td><td>缓存方法</td></tr><tr><td>#root.methodName</td><td>缓存方法的名字，是 #root.metdod.name 的简写形式</td></tr><tr><td>#result</td><td>方法调用的返回值（<strong>无法用在注解的 condition 属性中</strong>）</td></tr><tr><td>#Argument</td><td>任意的方法参数名（如 #argName）或参数索引（如 #a0 或 p0）</td></tr></tbody></table><p>可以根据项目需要选择合适的表达式来自定义 key。</p><h3 id="自定义缓存条件" tabindex="-1">自定义缓存条件 <a class="header-anchor" href="#自定义缓存条件" aria-label="Permalink to &quot;自定义缓存条件&quot;">​</a></h3><p>除了设置缓存条目的 key，我们还可以自定义条件来决定是否将缓存功能关闭。这里就要用到 <code>@Cacheable</code> 另外两个属性：condition 和 unless，它俩的格式还是用 SpEL 表达式。<code>@Cacheable</code> 和 <code>@CachePut</code> 共有的四个属性总结如下：</p><table tabindex="0"><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>要使用的缓存名称，每个缓存名称下面可以有很多 key</td></tr><tr><td>key</td><td>SpEL 表达式，用来计算自定义的缓存 key</td></tr><tr><td>condition</td><td>SpEL 表达式，如果得到的值为 false 的话，返回值不会放到缓存之中</td></tr><tr><td>unless</td><td>SpEL 表达式，如果得到的值为 true 的话，返回值不会放到缓存之中</td></tr></tbody></table><p>代码示例如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Cacheable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unless</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;#result.message.contains(&#39;NoCache&#39;)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>它的含义是：当放回的结果 message 字段包含有 NoCache 就不会进行缓存。</p><p>注意：</p><ul><li>condition 是对 <strong>入参</strong> 进行判断，符合条件的才会缓存，不符合条件的就不会进行缓存。</li><li><code>@Cacheable</code> 的 condition 属性能使用的 SpEL 语言只有 <code>#root</code> 和 <code>获取参数类的 SpEL 表达式</code>，<strong>不能使用返回结果的 #result</strong>，因为这个注解会在 <strong>进入方法前</strong> 去检测 condition，而这时还没有 result，会造成 result 为 null 的情况。</li><li>unless 是对 <strong>出参</strong> 进行判断，符合条件的不会进行缓存，不符合条件的才会缓存。</li><li>所以 <code>@Cacheable</code> 的 unless 属性可以使用 #result 表达式。</li></ul><h3 id="更新缓存" tabindex="-1">更新缓存 <a class="header-anchor" href="#更新缓存" aria-label="Permalink to &quot;更新缓存&quot;">​</a></h3><p><code>@CachePut</code> 也是用来更新缓存，和 <code>@Cacheable</code> 非常相似，不同点是 <code>@CachePut</code> 注解的方法始终都会执行，返回值也会也会放到缓存中。通常用在 <strong>保存</strong> 的方法上。</p><p>保存成功后，可以将 key 设置保存实例的 id。这个怎么做呢？</p><p>之前我们说过 key 可以通过 SpEL 表达式来指定，这里就可以搭配 <code>#result.id</code> 来实现。</p><p>这里还是用个例子来说明用法：创建题目的方法，返回题目实例，其中包含有题目 id。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/create&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CachePut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;#result.id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QuestionEntity </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Valid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QuestionEntity question){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IQuestionService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createQuestion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(question);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>保存的 id 是自增的，值为 123，所以缓存中的 key = passjava_123。</p><p><img src="`+k+`" alt="图片"></p><h3 id="删除缓存" tabindex="-1">删除缓存 <a class="header-anchor" href="#删除缓存" aria-label="Permalink to &quot;删除缓存&quot;">​</a></h3><p><code>@CacheEvict</code> 注解的方法在调用时不会在缓存中添加任何东西，但是会从从缓存中移除之前的缓存结果。</p><p>示例代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/remove/{id}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CacheEvict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> R </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PathVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) Long id){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    IQuestionService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> R.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ok</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>删除条目的 key 与传递进来的 id 相同。我测试的时候传的 id = 123，经过前缀 passjava_ 组装后就是 passjava_123，所以将之前缓存的 passjava_123 删除了。重复执行也不会报错。</p><p>注意：<code>@CacheEvict</code> 和 <code>@Cacheable</code>、<code>@CachePut</code> 不同，它能够应用在返回值为 void 的方法上。</p><p><code>@CacheEvict</code> 注解的属性，指定哪些缓存条目应该被移除掉，总结如下：</p><table tabindex="0"><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>要使用的缓存名称，每个缓存名称下面可以有很多 key</td></tr><tr><td>key</td><td>SpEL 表达式，用来计算自定义的缓存 key</td></tr><tr><td>condition</td><td>SpEL 表达式，如果得到的值为 false 的话，缓存不会应用到方法调用上</td></tr><tr><td>allEntries</td><td>如果为 true 的话，特定缓存的所有条目都会被移除掉</td></tr><tr><td>beforelnvocation</td><td>如果为 true 的话，方法调用之前移除条目；<br>否则，方法成功调用之后再移除条目。</td></tr></tbody></table><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本文通过传统使用缓存的方式的痛点引出 Spring 框架中的 Cache 组件。然后详细介绍了 Spring Cache 组件的用法：</p><ul><li>五大注解：@Cacheable、@CachePut、@CacheEvict、@Caching、@CacheConfig。</li><li>如何自定义缓存条目的 key。</li><li>如何自定义 Cache 配置。</li><li>如何自定义缓存的条件。</li></ul><p>当然 Spring Cache 并不是万能的，缓存一致性的问题依旧存在。</p>`,109)]))}const F=i(d,[["render",r]]);export{C as __pageData,F as default};
