import{_ as r,o as e,c as a,a6 as i}from"./chunks/framework.BkI9ovSD.js";const o="/assets/image-20210713202807818.CMuWfXiv.png",l="/assets/image-20210713203124797.C02u7Lbl.png",s="/assets/image-20210713203753373.e50XZJVo.png",n="/assets/image-20231124135437072.Bz8b8Va0.png",p="/assets/image-20210713204155887.D4ltkQ0b.png",_=JSON.parse('{"title":"初识微服务","description":"","frontmatter":{"title":"初识微服务","date":"2023-11-24T00:00:00.000Z","tags":["Microservices","SpringBoot"],"categories":["笔记"]},"headers":[],"relativePath":"blog/Note/初识微服务.md","filePath":"blog/Note/初识微服务.md","lastUpdated":1734486716000}'),g={name:"blog/Note/初识微服务.md"};function d(h,t,c,u,b,m){return e(),a("div",{"data-pagefind-body":!0},t[0]||(t[0]=[i('<h1 id="初识微服务" tabindex="-1">初识微服务 <a class="header-anchor" href="#初识微服务" aria-label="Permalink to &quot;初识微服务&quot;">​</a></h1><h2 id="单体架构" tabindex="-1">单体架构 <a class="header-anchor" href="#单体架构" aria-label="Permalink to &quot;单体架构&quot;">​</a></h2><p><strong>单体架构</strong> 就是将业务的所有功能都集中在一个项目中进行开发，并且最终打成一个包进行部署。</p><img src="'+o+'" alt="image-20210713202807818"><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li><li>适合小型项目</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="分布式架构" tabindex="-1">分布式架构 <a class="header-anchor" href="#分布式架构" aria-label="Permalink to &quot;分布式架构&quot;">​</a></h2><p><strong>分布式架构</strong> 是根据业务功能对系统进行拆分，每个业务功能模块都作为独立的项目进行开发，称为一个服务。</p><img src="'+l+'" alt="image-20210713203124797" style="zoom:67%;"><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><h2 id="服务治理" tabindex="-1">服务治理 <a class="header-anchor" href="#服务治理" aria-label="Permalink to &quot;服务治理&quot;">​</a></h2><p>分布式架构虽然相对于单体架构来说，降低了服务间的耦合度，但是服务拆分时有了很多新的问题需要思考：</p><ul><li>服务拆分的细粒度该如何界定？</li><li>服务之间以何种方式进行远程调用？</li><li>服务的调用关系如何进行统一管理？</li><li>服务的健康状态该如何感知？</li></ul><p>显然，人们需要制定一套行之有效的标准来约束分布式架构，而近几年最火爆的分布式架构方案就是 <strong>微服务</strong>。</p><h2 id="微服务" tabindex="-1">微服务 <a class="header-anchor" href="#微服务" aria-label="Permalink to &quot;微服务&quot;">​</a></h2><p>微服务是一种经过良好架构设计的 <strong>分布式架构</strong> 方案，其架构特征有：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复的业务开发</li><li>面向服务：微服务对外暴露统一标准的业务接口，与语言和技术无关</li><li>自治：团队独立、技术独立、数据独立，部署独立</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><img src="'+s+'" alt="image-20210713203753373" style="zoom:80%;"><h2 id="微服务结构" tabindex="-1">微服务结构 <a class="header-anchor" href="#微服务结构" aria-label="Permalink to &quot;微服务结构&quot;">​</a></h2><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性，做到高内聚，低耦合。</p><p>因此， <strong>微服务</strong> 是一种经过良好架构设计的 <strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务方案，在国内最知名的就是 SpringCloud 和阿里巴巴的 Dubbo。</p><p><img src="'+n+'" alt="image-20231124135437072"></p><h2 id="springcloud" tabindex="-1">SpringCloud <a class="header-anchor" href="#springcloud" aria-label="Permalink to &quot;SpringCloud&quot;">​</a></h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noreferrer">https://spring.io/projects/spring-cloud</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="'+p+'" alt="image-20210713204155887"></p><p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p><table tabindex="0"><thead><tr><th>Release Train</th><th>Release Train</th></tr></thead><tbody><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes" target="_blank" rel="noreferrer">2022.0.x</a> aka Kilburn</td><td>3.0.x, 3.1.x (Starting with 2022.0.3)</td></tr><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes" target="_blank" rel="noreferrer">2021.0.x</a> aka Jubilee</td><td>2.6.x, 2.7.x (Starting with 2021.0.3)</td></tr><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes" target="_blank" rel="noreferrer">2020.0.x</a> aka Ilford</td><td>2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes" target="_blank" rel="noreferrer">Hoxton</a></td><td>2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes" target="_blank" rel="noreferrer">Greenwich</a></td><td>2.1.x</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes" target="_blank" rel="noreferrer">Finchley</a></td><td>2.0.x</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes" target="_blank" rel="noreferrer">Edgware</a></td><td>1.5.x</td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes" target="_blank" rel="noreferrer">Dalston</a></td><td>1.5.x</td></tr></tbody></table>',35)]))}const k=r(g,[["render",d]]);export{_ as __pageData,k as default};
