import{_ as l,o as t,c as h,f as i,a,g as p,w as e,a6 as k,L as r}from"./chunks/framework.BkI9ovSD.js";const E="/assets/264.BVnwOJuW.png",A=JSON.parse('{"title":"Java的注解与反射机制","description":"","frontmatter":{"title":"Java的注解与反射机制","date":"2020-04-18T00:00:00.000Z","tags":["Java","注解","反射"],"categories":["Java"]},"headers":[],"relativePath":"blog/Java/Java的注解与反射机制.md","filePath":"blog/Java/Java的注解与反射机制.md","lastUpdated":1734487505000}'),d={name:"blog/Java/Java的注解与反射机制.md"};function g(o,s,y,c,u,F){const n=r("font");return t(),h("div",{"data-pagefind-body":!0},[s[2]||(s[2]=i("h1",{id:"java的注解与反射机制",tabindex:"-1"},[a("Java的注解与反射机制 "),i("a",{class:"header-anchor",href:"#java的注解与反射机制","aria-label":'Permalink to "Java的注解与反射机制"'},"​")],-1)),s[3]||(s[3]=i("h2",{id:"一、什么是注解",tabindex:"-1"},[a("一、什么是注解 "),i("a",{class:"header-anchor",href:"#一、什么是注解","aria-label":'Permalink to "一、什么是注解"'},"​")],-1)),s[4]||(s[4]=i("p",null,"Annotation 是从 JDK5.0 开始引入的技术",-1)),s[5]||(s[5]=i("p",null,"Annotation 的作用：",-1)),i("ul",null,[s[1]||(s[1]=i("li",null,"不是程序本身，可以对程序作出解释（这一点和注释[comment]没什么区别）",-1)),i("li",null,[p(n,{color:"red"},{default:e(()=>s[0]||(s[0]=[a("**可以被其他程序（比如：编译器等）读取**")])),_:1})])]),s[6]||(s[6]=k(`<p>Annotation 的格式：</p><p>注解是以 <strong>@注释名</strong> 在代码中存在的，还可以添加一些参数值，例如：<strong>@SuppressWarnings(value=&quot;unchecked&quot;)</strong></p><p>Annotation 在哪里使用：</p><ul><li>可以附加在 package , class , method , field 等上面，相当于给他们添加了额外的辅助信息，我们可以通过 <strong>反射机制</strong> 编程实现对这些元数据的访问</li></ul><p>内置注释：</p><ul><li><p><strong>@Override</strong>：定义在 java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</p></li><li><p><strong>@Deprecated</strong>：定义在 java.lang.Deprecated中，此注释可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</p></li><li><p><strong>@SuppressWarnings</strong>：定义在 java.lang.SuppressWarnings 中用来抑制编译时的警告信息。</p><p>与前两个注释有所不同，我们需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了。</p><p>@SuppressWarnings(&quot;all&quot;)</p><p>@SuppressWarnings(&quot;unchecked&quot;)</p><p>@SuppressWarnings(value={&quot;unchecked&quot;,&quot;deprecation&quot;})</p><p>……</p></li></ul><h2 id="二、元注解" tabindex="-1">二、元注解 <a class="header-anchor" href="#二、元注解" aria-label="Permalink to &quot;二、元注解&quot;">​</a></h2><p>元注解的作用是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型做说明</p><p>4个元注解分别为：</p><ul><li><strong>@Target</strong> 用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li><li><strong>@Retention</strong> 用于表示需要在什么级别保存注解信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;<strong>RUNTIME</strong>）</li><li><strong>@Document</strong> 说明该注解将被包含在 javadoc 中</li><li><strong>@Inherited</strong> 说明子类可以继承父类中的该注解</li></ul><p>测试元注解：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {ElementType.METHOD</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*方法*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*运行时有效*/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Documented</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //表示把注解生成在Javadoc中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Inherited</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //表示可以被继承</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyAnnotation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="三、自定义注解" tabindex="-1">三、自定义注解 <a class="header-anchor" href="#三、自定义注解" aria-label="Permalink to &quot;三、自定义注解&quot;">​</a></h2><p>使用 <strong>@interface</strong> 自定义注解时，自动继承了 <strong>java.lang.annotation.Annotation</strong> 接口</p><ul><li><strong>@interface</strong> 用来声明一个注解，格式：<strong>public @interface 注解名{定义内容}</strong></li><li>其中的每一个方法实际上是声明了一个配置参数</li><li>方法的名称就是参数的名称</li><li>返回值类型就是参数的类型（返回值只能是基本类型，Class，String，enum）</li><li>可以通过 default 来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为 value</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //注解可以显式赋值，如果没有默认值，就必须给注解赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyAnnotation1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">schools</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;BUPT&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //如果注解只有一个参数可以省略参数名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MyAnnotation2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;你好 &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.TYPE,ElementType.METHOD})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyAnnotation1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //注解的参数：类型+参数名()[default 默认值];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">default</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">default</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//默认值为-1，代表不存在</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schools</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ElementType.TYPE,ElementType.METHOD})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Retention</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> MyAnnotation2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //注解的参数：类型+参数名()[default 默认值];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="四、什么是java的反射机制" tabindex="-1">四、什么是Java的反射机制 <a class="header-anchor" href="#四、什么是java的反射机制" aria-label="Permalink to &quot;四、什么是Java的反射机制&quot;">​</a></h2><p>Java的反射（Reflection）机制是指在程序的运行状态中，（通过借助ReflectionAPI）可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以获取任意一个类的成员变量和方法（类的内部信息），可以操作任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射是java被视为动态语言的关键。</p><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p><h3 id="_1、动态语言" tabindex="-1">1、动态语言 <a class="header-anchor" href="#_1、动态语言" aria-label="Permalink to &quot;1、动态语言&quot;">​</a></h3><p>是一类在运行时可以改变其结构的语言：例如新的函数、对象甚至代码可以被引进，已有的函数可以被删除或者是其他结构上的变化。通俗来说就是运行时代码可以根据一些条件来改变自身的结构</p><p>主要动态语言：Object-C、C#、JavaScript、PHP、Python等</p><h3 id="_2、静态语言" tabindex="-1">2、静态语言 <a class="header-anchor" href="#_2、静态语言" aria-label="Permalink to &quot;2、静态语言&quot;">​</a></h3><p>与动态语言相对应的，运行时不能改变其结构，如 Java、C、C++</p><p>Java不是动态语言，但是 Java 可以称为是 <strong>准动态语言</strong>。即 Java 有一定的动态性，可以利用 <strong>反射机制</strong> 获得类似动态语言的特性。Java的动态性使得编程时更加灵活。</p><h2 id="五、什么是类对象" tabindex="-1">五、什么是类对象 <a class="header-anchor" href="#五、什么是类对象" aria-label="Permalink to &quot;五、什么是类对象&quot;">​</a></h2><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口</p><p>对于每个类而言，JRE都为其保留一个不变的Class类型的对象</p><p>一个Class对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息</p><ul><li>Class 本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个 Class 实例</li><li>一个 Class 对象对应的是一个加载到 JVM 中的一个 <code>.class</code> 文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过 Class 可以完整地得到一个类中的所有被加载的结构</li><li>Class 类是反射机制的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul><p>在理解类对象之前，先说我们熟悉的对象之间的区别：</p><ul><li>garen 和 teemo 都是<strong>Hero对象</strong>，他们的区别在于，各自有<strong>不同的名称，血量，伤害值</strong>。</li></ul><p>然后说说类之间的区别：</p><ul><li>Hero 和 Item 都是类，他们的区别在于有<strong>不同的方法，不同的属性</strong>。</li></ul><p><strong>类对象</strong>，就是用于描述这种类，都有什么属性，什么方法的</p><h2 id="六、class类的常用方法" tabindex="-1">六、Class类的常用方法 <a class="header-anchor" href="#六、class类的常用方法" aria-label="Permalink to &quot;六、Class类的常用方法&quot;">​</a></h2><p><img src="`+E+`" alt=""></p><h2 id="七、如何获取类对象" tabindex="-1">七、如何获取类对象 <a class="header-anchor" href="#七、如何获取类对象" aria-label="Permalink to &quot;七、如何获取类对象&quot;">​</a></h2><p>获取类对象主要有5种方式</p><ol><li><p><code>Class.forName</code> 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法 forName() 获取，可能抛出 ClassNotFoundException</p></li><li><p><code>Hero.class</code> 若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高</p></li><li><p><code>new Hero().getClass()</code> 已知某个类的实例（即对象），调用该实例的 getClass() 方法获取 Class 对象</p></li><li><p><code>.Type</code> 内置基本数据类型可以直接用类名</p></li><li><p>还可以利用 <code>ClassLoader</code></p></li></ol><p>在一个 JVM 中，一种类，只会有一个类对象存在。所以以上几种方式取出来的类对象，都是一样的</p><p>准确的讲是一个 ClassLoader 下，一种类，只会有一个类对象存在。通常一个 JVM 下，只会有一个 ClassLoader</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Class pClass1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Class.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;charactor.Hero&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Class pClass2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Hero.class;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Class pClass3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Hero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="八、获取类对象的时候-会导致类属性被初始化" tabindex="-1">八、获取类对象的时候，会导致类属性被初始化 <a class="header-anchor" href="#八、获取类对象的时候-会导致类属性被初始化" aria-label="Permalink to &quot;八、获取类对象的时候，会导致类属性被初始化&quot;">​</a></h2><p>无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次（除了直接使用 <code>Class c = Hero.class</code> 这种方式，这种方式不会导致静态属性被初始化）</p><h2 id="九、通过反射机制创建对象" tabindex="-1">九、通过反射机制创建对象 <a class="header-anchor" href="#九、通过反射机制创建对象" aria-label="Permalink to &quot;九、通过反射机制创建对象&quot;">​</a></h2><p>与传统的通过 new 来获取对象的方式不同</p><p>反射机制，会先拿到Hero的“类对象”，然后通过类对象获取“构造器对象”</p><p>再通过构造器对象创建一个对象</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传统的使用new的方式创建对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hero h1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Hero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h1.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;teemo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用反射的方式创建对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;charactor.Hero&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Class pClass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Class.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(className);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构造器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Constructor c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pClass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getConstructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过构造器实例化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hero h2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Hero) c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="十、通过反射机制修改对象的属性" tabindex="-1">十、通过反射机制修改对象的属性 <a class="header-anchor" href="#十、通过反射机制修改对象的属性" aria-label="Permalink to &quot;十、通过反射机制修改对象的属性&quot;">​</a></h2><p>对于private修饰的成员，需要使用 <code>setAccessible(true)</code> 才能访问和修改</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hero h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Hero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用传统方式修改name的值为garen</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;garen&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//获取类Hero的名字叫做name的字段</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Field f1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDeclaredField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//修改这个字段的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(h, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;teemo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>getField 和 getDeclaredField 的区别：</p><ul><li>这两个方法都是用于获取字段</li><li>getField <strong>只能获取</strong>public的，包括<strong>从父类继承</strong>来的字段。</li><li>getDeclaredField 可以获取本类所有的字段，<strong>包括private</strong>的，但是<strong>不能获取继承</strong>来的字段。 (<strong>注</strong>： 这只能获取到private的<strong>字段</strong>，但并不能访问该private字段的<strong>值</strong>，除非加上 <strong>setAccessible(true)</strong>)</li></ul><h2 id="十一、通过反射机制-调用一个对象的方法" tabindex="-1">十一、通过反射机制，调用一个对象的方法 <a class="header-anchor" href="#十一、通过反射机制-调用一个对象的方法" aria-label="Permalink to &quot;十一、通过反射机制，调用一个对象的方法&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Hero h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Hero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取这个名字叫做setName，参数类型是String的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Method m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, String.class);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对h对象，调用这个方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">m.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(h, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;盖伦&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用传统的方式，调用getName方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(h.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><h2 id="十二、反射机制好在哪里" tabindex="-1">十二、反射机制好在哪里 <a class="header-anchor" href="#十二、反射机制好在哪里" aria-label="Permalink to &quot;十二、反射机制好在哪里&quot;">​</a></h2><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><p>通常来说，需要在学习了<strong>Spring</strong>的<strong>依赖注入</strong>，<strong>反转控制</strong>之后，才会对反射有更好的理解。</p>`,60))])}const D=l(d,[["render",g]]);export{A as __pageData,D as default};
