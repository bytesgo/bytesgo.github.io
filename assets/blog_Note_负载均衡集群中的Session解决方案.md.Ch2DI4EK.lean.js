import{_ as e,o as i,c as a,a6 as o}from"./chunks/framework.BkI9ovSD.js";const n="/assets/417.D568y1Dc.png",u=JSON.parse('{"title":"负载均衡集群中的Session解决方案","description":"在我们给 Web 站点使用负载均衡之后，必须面临的一个重要问题就是 Session 的处理办法，无论是 PHP、Python、Ruby 还是Java，只要使用服务器保存 Session，在做负载均衡时都需要考虑 Session 的问题。","frontmatter":{"title":"负载均衡集群中的Session解决方案","date":"2020-09-23T00:00:00.000Z","description":"在我们给 Web 站点使用负载均衡之后，必须面临的一个重要问题就是 Session 的处理办法，无论是 PHP、Python、Ruby 还是Java，只要使用服务器保存 Session，在做负载均衡时都需要考虑 Session 的问题。","tags":["Session","Redis"],"categories":["笔记"]},"headers":[],"relativePath":"blog/Note/负载均衡集群中的Session解决方案.md","filePath":"blog/Note/负载均衡集群中的Session解决方案.md","lastUpdated":1734587597000}'),t={name:"blog/Note/负载均衡集群中的Session解决方案.md"};function r(l,s,h,p,d,S){return i(),a("div",{"data-pagefind-body":!0},s[0]||(s[0]=[o('<h1 id="负载均衡集群中的session解决方案" tabindex="-1">负载均衡集群中的Session解决方案 <a class="header-anchor" href="#负载均衡集群中的session解决方案" aria-label="Permalink to &quot;负载均衡集群中的Session解决方案&quot;">​</a></h1><h2 id="session-为啥会出问题" tabindex="-1">Session 为啥会出问题 <a class="header-anchor" href="#session-为啥会出问题" aria-label="Permalink to &quot;Session 为啥会出问题&quot;">​</a></h2><p>从客户端来解释，我们知道当用户的第一次访问被负载均衡代理到后端服务器 A 并登录后，服务器 A 上会保留用户的登录信息。</p><p>当用户再次发送请求时，根据负载均衡策略，该请求可能被代理到后端不同的服务器上，例如服务器 B 。</p><p>可是，由于 <strong>Session 不是所有服务器共享的</strong>，所以这台服务器 B 没有用户的登录信息，该用户再发送请求时需要重新登录，这对访问者来说是难以接受的。</p><p>所以，在实施负载均衡的时候，我们必须考虑 Session 的问题。</p><p>在负载均衡中，针对Session的处理，我们一般有以下几种方法：</p><ol><li>Session 保持</li><li>Session 复制</li><li>Session 共享（最常用）</li><li>Session 持久化</li></ol><h2 id="会话保持-sticky-sessions" tabindex="-1">会话保持（Sticky Sessions） <a class="header-anchor" href="#会话保持-sticky-sessions" aria-label="Permalink to &quot;会话保持（Sticky Sessions）&quot;">​</a></h2><h3 id="如何进行会话保持" tabindex="-1">如何进行会话保持 <a class="header-anchor" href="#如何进行会话保持" aria-label="Permalink to &quot;如何进行会话保持&quot;">​</a></h3><p>Session 保持（会话保持、粘滞会话）是我们见到最多的名词之一。</p><p>所谓会话保持，就是让负载均衡进行请求分发的时候 <strong>保证每个客户端固定地访问到后端的同一台应用服务器</strong>。</p><p>会话保持方案在所有的负载均衡都有对应的实现，而且这是在负载均衡这一层就解决了 Session 问题的方案。</p><p><strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip的所有请求都定向到同一台服务器上，也就是说将用户与服务器绑定。</strong></p><p>用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</p><h3 id="会话保持的缺点" tabindex="-1">会话保持的缺点 <a class="header-anchor" href="#会话保持的缺点" aria-label="Permalink to &quot;会话保持的缺点&quot;">​</a></h3><p>会话保持看似解决了 Session 同步的问题，但是却带来的一些其它方面的问题：</p><ul><li><strong>负载不均衡了</strong>：由于使用了 Session 保持，很显然，根本无法保证负载绝对的均衡了。</li><li><strong>没有彻底解决问题</strong>：如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 Session 信息都将失效。</li></ul><h2 id="会话复制" tabindex="-1">会话复制 <a class="header-anchor" href="#会话复制" aria-label="Permalink to &quot;会话复制&quot;">​</a></h2><h3 id="如何进行会话复制" tabindex="-1">如何进行会话复制 <a class="header-anchor" href="#如何进行会话复制" aria-label="Permalink to &quot;如何进行会话复制&quot;">​</a></h3><p>既然我们的目标是所有服务器上都要保持用户的 Session，那么 <strong>将每个应用服务器中的 Session 信息复制到其它服务器节点上</strong> 是不是就可以呢？</p><p>答案是肯定的。</p><p>而这就是 Session 的第二种处理办法：<strong>会话复制</strong>。</p><ul><li>任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 Session ，以此来保证 Session 同步。</li></ul><p>会话复制在 Tomcat 上得到了支持，它是基于 IP 组播（multicast）来完成 Session 的复制（Tomcat 的配置如果有需求可以参考 Tomcat 官方文档），Tomcat 的会话复制分为两种：</p><ul><li>全局会话复制：利用 Delta Manager 复制会话中的变更信息到集群中的所有其他节点。</li><li>非全局复制：使用 Backup Manager 进行复制，它会把 Session 复制给一个指定的备份节点。</li></ul><h3 id="会话复制的缺点" tabindex="-1">会话复制的缺点 <a class="header-anchor" href="#会话复制的缺点" aria-label="Permalink to &quot;会话复制的缺点&quot;">​</a></h3><p>会话复制会对网络负荷造成一定压力，如果 Session 量大的话可能会造成网络堵塞，拖慢服务器性能。</p><p>根据笔者在生产的实践案例，在集群超过6个节点之后就会出现各种问题，不推荐生产使用。</p><h2 id="会话共享-最常用" tabindex="-1">会话共享（最常用） <a class="header-anchor" href="#会话共享-最常用" aria-label="Permalink to &quot;会话共享（最常用）&quot;">​</a></h2><h3 id="如何进行会话-共享" tabindex="-1">如何进行会话+共享 <a class="header-anchor" href="#如何进行会话-共享" aria-label="Permalink to &quot;如何进行会话+共享&quot;">​</a></h3><p>既然会话保持和会话复制都不完美，那么我们为什么不 <strong>把 Session 放在一个统一的地方</strong> 呢，这样 <strong>集群中的所有节点都在一个地方进行 Session 的存取</strong> 就可以解决问题。</p><p>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群。</p><p>把 Session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：</p><ul><li>实现了 Session 共享</li><li>可以水平扩展（增加 Redis 服务器）</li><li>服务器重启 Session 不丢失（不过也要注意 Session 在 Redis 中的刷新/失效机制）</li><li>不仅可以跨服务器 Session 共享，甚至可以跨平台（例如网页端和 APP 端）</li></ul><p><img src="'+n+'" alt=""></p><h2 id="会话持久化" tabindex="-1">会话持久化 <a class="header-anchor" href="#会话持久化" aria-label="Permalink to &quot;会话持久化&quot;">​</a></h2><p>对于 Session 来说，肯定是要频繁使用的，我们可以将 Session 存储到数据库中，保证 Session 的持久化。</p><p>这样的话，即使服务器出现问题，Session 也不会丢失。</p><h3 id="会话持久化的缺点" tabindex="-1">会话持久化的缺点 <a class="header-anchor" href="#会话持久化的缺点" aria-label="Permalink to &quot;会话持久化的缺点&quot;">​</a></h3><p>如果网站的访问量很大，把 Session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p><p>虽然我们可以把 Session 存放在数据库里，但是真正的生产环境中，更推荐把 Session 存放在性能更快的 <strong>分布式 KV 数据</strong> 中，例如： Memcached 和 Redis。</p>',42)]))}const b=e(t,[["render",r]]);export{u as __pageData,b as default};
